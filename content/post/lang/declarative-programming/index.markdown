
# 编程范式

编程范式的一般概念如下：范式译自英文的paradigm，也有译作典范、范型、范例的。所谓编程范式（programming paradigm），指的是计算机编程的基本风格或典范模式。借用哲学的术语，如果说每个编程者都在创造虚拟世界，那么编程范式就是他们置身其中自觉不自觉采用的世界观和方法论。

托马斯.库恩提出“科学的革命”的范式论之后，Robert Floyd在1979年图灵奖的颁奖演说中使用了编程范式一词。编程范式一般包括三个方面，以OOP为例：

- 学科的逻辑体系——规则范式：如类/对象、继承、动态绑定、方法改写、对象替换等等机制。
- 心理认知因素——心理范式：按照面向对象编程之父Alan Kay的观点，“计算就是模拟”。OO范式极其重视隐喻（metaphor）的价值，通过拟人化，按照自然的方式模拟自然。
- 自然观/世界观——观念范式：强调程序的组织技术，视程序为松散耦合的对象/类的集合，以继承机制将类组织成一个层次结构，把程序运行视为相互服务的对象们之间的对话。

简单的说，编程范式是程序员看待程序应该具有的观点。

我们知道，编程是为了解决问题，而解决问题可以有多种视角和思路，其中普适且行之有效的模式被归结为范式。比如我们常用的“面向对象编程”就是一种范式。

由于着眼点和思维方式的不同，相应的范式自然各有侧重和倾向，因此一些范式常用‘oriented’来描述。换言之，每种范式都引导人们带着某种的倾向去分析问题、解决问题，这不就是“导向”吗？

> 如果把一门编程语言比作兵器，它的语法、工具和技巧等是招法，它采用的编程范式则是心法。

编程范式是抽象的，必须通过具体的编程语言来体现。它代表的世界观往往体现在语言的核心概念中，代表的方法论往往体现在语言的表达机制中。

一种范式可以在不同的语言中实现，一种语言也可以同时支持多种范式。比如，PHP可以面向过程编程，也可以面向对象编程。任何语言在设计时都会倾向某些范式，同时回避某些范式，由此形成了不同的语法特征和语言风格。

> 抽象的编程范式须要通过具体的编程语言来体现。范式的世界观体现在语言的核心概念之中，范式的方法论体现在语言的表达机制中。一种语言的语法和风格与其所支持的编程范式密切相关。


如果对编程范式感兴趣，可以扩展阅读：[《编程范式，程序员的编程世界观》](http://www.nowamagic.net/librarys/veda/detail/2488)


# 函数式编程思维

函数式编程与命令式编程最大的不同其实在于：

函数式编程关心数据的映射，命令式编程关心解决问题的步骤

这里的映射就是数学上“函数”的概念——一种东西和另一种东西之间的对应关系。

这也是为什么“函数式编程”叫做“函数式编程”。



# 声明式编程范式初探

语言编程语言可以分成两类：

- 命令式
- 声明式

事实上，凡是非命令式的编程都可归为声明式编程。因此，命令式、函数式和逻辑式是最核心的三种范式。为清楚起见，我们用一幅图来表示它们之间的关系。

<img alt="index-d30e6951.png" src="images/index-d30e6951.png" width="" height="" >

与命令式编程相对的声明式编程（declarative programming）。顾名思义，声明式编程由若干规范（specification）的声明组成的，即一系列陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。

## 声明式编程的发源

声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming，简称FP）和逻辑式编程（logic programming，简称LP）。其中，函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推导或论证结论。

其实支持它们的语言出现得并不比命令式的晚多少——最早的函数式语言Lisp（LISt Processor）已有半个世纪的历史，最早之一的逻辑式语言Prolog（PROgramming in LOGic）也与C同龄。只是由于大多数更多地用于学术研究而非商业应用，颇有些‘养在深闺人未识’的味道。

起源的不同决定了这两大类范式代表着迥然不同的编程理念和风格：命令式编程是行动导向（Action-Oriented）的，因而算法是显性而目标是隐性的；声明式编程是目标驱动（Goal-Driven）的，因而目标是显性而算法是隐性的。为便于说明，我们分别用三种代表性的语言来实现阶乘（factorial）运算。

**阶乘的三种编程实现**

C（命令式）——

```
int factorial(int n)
{
	int f = 1;
	for (; n > 0; --n) f *= n;
	return f;
}
```

Lisp（函数式）——

```
(defun factorial(n)
  (if (= n 0)
	1                               //  若n等于0，则n!等于1
	(* n (factorial(- n 1)))))      //  否则n!等于n* (n-1)
```

Prolog（逻辑式）——

```
// 0! 等于1
factorial(0,1).
// 若M等于N-1且 M!等于Fm且F等于N*Fm，则N! 等于F
factorial(N,F) :-   M is N-1, factorial(M,Fm), F is N * Fm.
```


以上三段代码区别在哪里？C明确给出了阶乘的迭代算法，而Lisp仅描述了阶乘的递归定义，Prolog则陈述了两个关于阶乘的断言。


## 声明式编程的本质
我们最早接触的变量是代数方程中的x、y、z等，本质上是抽象化的符号，变量值是该符号在给定约束条件下的允许值。而命令式编程中的变量本质上是抽象化的内存，变量值是该内存的储存内容。通俗地说，前者好比姓名，所指之人是固定的；后者好比住址，所住之人是变化的。此外，等号在代数中是一种约束，而在许多命令式语言中则表示赋值。因此 i = i + 1 可以在命令式编程中出现，但绝不可能在数学推理中出现 —— 除非在反证法中。

声明式编程让我们重回数学思维：函数式编程类似代数中的表达式变换和计算，逻辑式编程则类似数理逻辑推理。其中的变量也如数学中的一样，是抽象符号而非内存地址，因此没有赋值运算，不会产生变量被改写的副作用（side-effect），也不存在内存分配和释放的问题。这既简化了代码，也减少了调试——不妨想一想，有多少bug是由于某个变量被意外改写或内存管理不慎而造成的？


**声明式语言与命令式语言的相通之处**

- 首先，所有高级语言都建立于低级语言之上，最终转化为机器语言，声明式语言也不例外。
- 其次，声明式语言与命令式语言并非泾渭分明，而是互相交叉渗透的。一些‘非纯粹’ 的声明式语言也提供变量赋值和流程控制，而一些命令式语言也在逐渐发展，通过利用其他程序或增加新的语言特征来实现声明式编程。

总的说来，在命令式语言中融入声明式的元素应当是一种趋势。尤其是函数式，它的一些特征已经在许多命令式语言中得到了支持。比较而言，声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简洁清晰、易于修改和维护。从这种意义上说，声明式语言天然地就比命令式语言更高级。

其实用Lisp实现阶乘的方法也可以用在C上：

```
int factorial(int n)
{
    return n == 0 ? 1 : n * factorial(n - 1);
}
```

这是C的递归实现。除了细微的语法差别外，二者的确很相似，这说明用命令式语言也可以讲出声明式的味道。实际上，命令式语言提倡迭代而不鼓励递归，早期的Fortran 甚至都不支持递归。一则迭代比递归更符合命令式的思维模式，因为前者贴近机器语言而后者贴近数学语言；二则除尾递归（tail recursion）外，一般递归比迭代的开销（overhead）大。相反，声明式语言提倡递归而不支持迭代。就语法而言，它不允许迭代中的循环变量；就视角而言，迭代着眼微观过程而递归着眼宏观规律。

具体可以看看这个：[漫谈递归](http://www.nowamagic.net/librarys/veda/special/%E6%BC%AB%E8%B0%88%E9%80%92%E5%BD%92)

归根结底，编程是寻求一种机制，将指定的输入转化为指定的输出。三种范式对此提供了截然不同的解决方案：

- 命令式把程序看作一个自动机，输入是初始状态，输出是最终状态，编程就是设计一系列指令，通过自动机执行以完成状态转变；
- 函数式把程序看作一个数学函数，输入是自变量，输出是因变量，编程就是设计一系列函数，通过表达式变换以完成计算；
- 逻辑式把程序看作一个逻辑证明，输入是题设，输出是结论，编程就是设计一系列命题，通过逻辑推理以完成证明。

绘成表格如下：

<img alt="index-9dc988e3.png" src="images/index-9dc988e3.png" width="" height="" >



# 函数式编程

阿隆佐·丘奇提出了一个被称为 λ 演算（lambda calculus）的形式系统。这个系统本质上是一种虚拟的机器的编程语言，他的基础是一些以函数为参数和返回值的函数。函数用希腊字母 λ 标识，这个形式系统因此得名。利用这一形式系统，阿隆佐就可以对上述诸多问题推理并给出结论性的答案。

独立于阿隆佐，阿兰·图灵也在进行着相似的工作，他提出了一个不同的形式系统（现在被称为图灵机），并使用这一系统独立地给出了和阿隆佐相似的结论。后来人们证明图灵机和 λ 演算能力等同。

λ 演算被设计用来探询关于计算的问题，所以函数式编程主要处理计算，并用函数来完成这一过程。函数是函数式编程的基本单位，函数几乎被用于一切，包括最简单的计算，甚至变量都由计算取代。在函数式编程中，变量只是表达式的别名（这样我们就不必把所有东西打在一行里）。变量是不能更改的，所有变量只能被赋值一次。


如果每个符号都是不可变更(non-mutable)的，那么就无法改变任何状态！其实事实并非完全如此。在阿隆佐研究其 λ 演算时，他并不想将某个状态维护一段时间以期未来对其进行修改。他关注的是对数据的操作（也通常被称为“演算体 caculating stuff”）。既然已经证明 λ 演算与图灵机等价，它可以完成所有命令式编程语言能够完成的任务。那么，我们怎么才能做到呢？

答案是函数式程序能保存状态，只是它并非通过变量而是使用函数来保存状态。状态保存在函数的参数中，保存在堆栈上。如果你要保存某个状态一段时间并时不时地对其进行一些修改，可以写个递归函数。举个例子，我们写个函数来翻转 Java 的字符串。记住，我们声明的每个变量默认都是 final 的。


```java
String reverse(String arg) {
    if(arg.length == 0) {
        return arg;
    }
    else {
        return reverse(arg.substring(1, arg.length)) + arg.substring(0,1);
    }
}
```

> 这个函数很慢，因为它不断地调用自己，它还是个嗜内存魔，因为要持续分配对象。不过它的确是在用函数式风格。你可能会问，怎么有人会这样写程序？

函数式编程的本质：洞察到程序实际上可以按照纯粹的数学函数来编写；也就是说，每次给这些函数传递相同的输入时，它们将总是返回相同的值，并且不会产生副作用。在函数式编程中编写代码类似于在数学中组合函数。

争用是在多核心cpu上运行的代码最大的性能杀手




## 函数式编程的优点

函数式程序被认为更容易阅读，但这是比较主观的判断，还有一些客观的优点：

**单元测试**

因为函数式编程的每一个符号都是 final 的，没有函数产生过副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用（如类成员或全局变量）。这意味着函数求值的结果只是其返回值，而惟一影响其返回值的就是函数的参数。

这是单元测试者的梦中仙境（wet dream）。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在 Java 或 C++ 中只检查函数的返回值还不够——我们还必须验证这个函数可能修改了的外部状态。

**调试**

如果一个函数式程序不如你期望地运行，调试也是轻而易举。因为函数式程序的 bug 不依赖于执行前与其无关的代码路径，你遇到的问题就总是可以再现。在命令式程序中，bug 时隐时现，因为在那里函数的功能依赖与其他函数的副作用，你可能会在和 bug 产生无关的方向探寻很久，毫无收获。函数式程序就不是这样——如果一个函数的结果是错误的，那么无论之前你还执行过什么，这个函数总是返回相同的错误结果。

一旦你将那个问题再现出来，寻其根源将毫不费力，甚至会让你开心。中断那个程序的执行然后检查调用栈，和命令式编程一样，栈里每一次函数调用的参数都呈现在你眼前。但是在命令式程序中只有这些参数还不够，函数还依赖于成员变量，全局变量和其他类的状态（它们也依赖着同样多的其他东西）。函数式程序里函数只依赖于它的参数，而那些信息就在你注视的目光下！还有，在命令式程序里，只检查一个函数的返回值不能够让你确信这个函数已经正常工作了，你还要去查看那个函数作用域外数十个对象的状态来确认。对函数式程序，你要做的所有事就是查看其返回值！

沿着堆栈检查函数的参数和返回值，只要发现一个不尽合理的结果就进入那个函数然后一步步跟踪下去，重复这一个过程，直到它让你发现了 bug 的生成点。

**并行**

函数式程序无需任何修改即可并行执行。不用担心死锁和临界区，因为你从未用锁！函数式程序里没有任何数据被同一线程修改两次，更不用说两个不同的线程了。这意味着可以不假思索地简单增加线程而不会引发折磨着并行应用程序的传统问题。

事实既然如此，为什么并不是所有人都在需要高度并行作业的应用中采用函数式程序？嗯，他们正在这样做。

爱立信公司设计了一种叫作 Erlang 的函数式语言并将它使用在需要极高抗错性和可扩展性的电信交换机上。还有很多人也发现了 Erlang 的优势并开始使用它。我们谈论的是电信通信控制系统，这与设计华尔街的典型系统相比对可靠性和可升级性要求高得多。实际上，Erlang 系统并不是“可伸缩”和“可靠”——Java 系统才是——Erlang 系统是“坚如磐石”。

关于并行的故事还没有就此停止，即使你的程序本身就是单线程的，那么函数式程序的编译器仍然可以优化它使其运行于多个 CPU 上。请看下面这段代码：

```java
String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
```

在函数式是编程语言中，编译器会分析代码，辨认出潜在耗时的创建字符串 s1 和 s2 的函数，然后并行地运行它们。

这在命令式语言中是不可能的，因为在那里，每个函数都有可能修改了函数作用域以外的状态并且其后续的函数又会依赖这些修改。

在函数式语言里，自动分析函数并找出适合并行执行的候选函数简单的像自动进行的函数内联化！在这个意义上，函数式风格的程序是“不会过时的技术（future proof）”（虽然不喜欢用行业广告语，但这里要破例一次）。硬件厂商已经无法让 CPU 运行得更快了，于是他们增加了处理器核心的速度并因并行而获得了四倍的速度提升。当然他们也顺便忘了提及：我们多花的钱只对支持并行运行的软件有用，只有一小部分的命令式程序可以（不加修改地）并行运行在这些新的硬件上，而 100% 的（纯）函数式程序都可以，因为函数式程序天生支持并行处理。



**代码热部署**

过去要在 Windows 上安装更新，重启计算机是难免的，而且还不只一次，即使只是安装了一个新版的媒体播放器。Windows XP 大大改进了这一状态，但仍不理想（我今天工作时运行了 Windows Update，现在一个烦人的图标总是显示在托盘里除非我重启一次机器）。

Unix 系统一直以来以更好的模式运行，安装更新时只需停止系统相关的组件，而不是整个操作系统。即使如此，对一个大规模的服务器应用这还是不能令人满意的。电信系统必须 100% 时间在线运行，因为如果在系统更新时紧急拨号失效，就可能造成生命损失。华尔街的公司也没有理由必须在周末停止服务以安装更新。

理想的情况是完全不停止系统任何组件来更新相关的代码。在命令式的世界里这是不可能的。

考虑运行时上载一个 Java 类并重载一个新的定义，那么所有这个类的实例都将不可用，因为它们被保存的状态丢失了。我们可以着手写些繁琐的版本控制代码来解决这个问题，然后将这个类的所有实例序列化，再销毁这些实例，继而用这个类新的定义来重新创建这些实例，然后载入先前被序列化的数据并希望载入代码可以不出问题地将这些数据移植到新的实例。在此之上，每次更新都要重新手动编写这些用来移植的代码，而且要相当谨慎地防止破坏对象间的相互关系。理论简单，但实践可不容易。

对函数式的程序，所有的状态即传递给函数的参数都被保存在了堆栈上，这使的热部署轻而易举！实际上，所有我们需要做的就是对工作中的代码和新版本的代码做一个差异比较，然后部署新代码。其他的工作将由一个语言工具自动完成！如果你认为这是个科幻故事，请再思考一下：多年来 Erlang 工程师一直更新着他们在线上运转着的系统，而无需中断它。

**机器辅助的推理和优化**

函数式语言的一个有趣的属性就是他们可以用数学方式推理。因为一种函数式语言只是一个形式系统的实现，所有在纸上完成的运算都可以应用于以这种语言书写的程序。比如，编译器可以把一段代码变换为等价但更高效的代码，由于变化遵循严格的数学原理其等价性是可证明的。多年来关系型数据库一直在进行着这类优化，没有理由不能把这一技术应用到常规软件上。

另外，还能使用这些技术来证明部分程序的正确，甚至可能创建工具来分析代码并为单元测试自动生成边界用例！这对那些要求极其稳定的系统价值不可估量，比如心脏起搏器（pacemaker）或空中交通控制系统；如果你编写的不是非常关键的应用，这类工具也是让你领先于竞争对手的杀手锏。


## 高阶函数

我记得自己在了解了上面列出的种种优点后曾想：“这都很棒，可是如果我不得不用天生残缺的语言对着全是 final 的变量编程，好特性也毫无意义。” 这其实是误解。在如 Java 这般的命令式语言环境里，所有变量都是 final 将带来一堆问题，但是在函数式语言里并非如此，函数式语言提供了不同的抽象工具使你忘记曾经习惯于修改变量。高阶函数就是这样一种工具。

函数式语言中的函数不同于 Java 或 C 中的函数，而是一个超集——它有着 Java 函数拥有的所有功能，但还有更多。创建函数的方式和 C 中相似:

```c
int add(int i, int j) {
    return i + j;
}
```

这里有些东西和等价的 C 代码有区别。现在扩展我们的 Java 编译器使其支持这种记法：当我们输入上述代码后编译器会把它转换成下面的 Java 代码（别忘了，所有东西都是 final 的）：

```java
class add_function_t {
    int add(int i, int j) {
        return i + j;
    }
}

add_function_t add = new add_function_t();
```

这里的符号 add 并不是一个函数。这是一个有一个成员函数的很小的类。

我们现在可以把 add 作为函数参数放入我们的代码中。还可以把它赋给另一个符号。我们在运行时创建的 add_function_t 的实例如果不再被使用就将会被垃圾回收掉。这些使得函数成为第一级的对象无异于整数或字符串。操作（作为参数的）函数的函数被称为高阶函数。

那么何时以及如何使用高阶函数呢？我很高兴你这样问，如果你不曾考虑类的继承层次，就可能写出一整团堆砌的代码块。当你发现其中一些代码重复出现，就把他们提取成函数（幸运的是这些依然可以在学校里学到），如果你发现在那个函数里一些逻辑动作根据情况有变，就把他提取成高阶函数。糊涂了？下面是 一个来自我工作中的实例：假如我的一些 Java 代码接受一条信息，用多种方式处理它然后转发到其他服务器。

```java
class MessageHandler {
    void handleMessage(Message msg) {
        // …
        msg.setClientCode(”ABCD_123″);
        // …
        sendMessage(msg);
    }
    // …
}
```

假设现在要更改这个系统，我们要把信息转发到两个服务器而不是一个，一切基本都像刚才一样，但第二个服务器接受另一种客户代码（client code）格式，怎么处理这种情况？我们可以检查信息的目的地并相应修改客户端代码的格式，如下：

```java
class MessageHandler {
    void handleMessage(Message msg) {
        // …
        if(msg.getDestination().equals(”server1″) {
            msg.setClientCode(”ABCD_123″);
        } else {
            msg.setClientCode(”123_ABC”);
        }
        // …
        sendMessage(msg);
    }
    // …
}
```

然而这不是可扩展的方法，如果加入了更多的服务器，这个函数将线性增长，更新它会成为梦魇。面向对象的方法是把 MessageHandler 作为基类，在子类中定制客户代码操作：

```java
abstract class MessageHandler {
    void handleMessage(Message msg) {
        // …
        msg.setClientCode(getClientCode());
        // …
        sendMessage(msg);
    }
    abstract String getClientCode();
    // …
}

class MessageHandlerOne extends MessageHandler {
    String getClientCode() {
        return “ABCD_123″;
    }
}

class MessageHandlerTwo extends MessageHandler {
    String getClientCode() {
        return “123_ABCD”;
    }
}
```

现在就可以对每个服务器实例化一个适合的处理类，添加服务器的操作变得容易维护了。但对于这么一个简单的修改仍然要添加大量的代码。为了支持不同的客户代码我们创建了两个新的类型！现在我们用高阶函数完成同样的功能：

```
class MessageHandler {
    void handleMessage(Message msg, Function getClientCode) {
        // …
        Message msg1 = msg.setClientCode(getClientCode());
        // …
        sendMessage(msg1);
    }
    // …
}

String getClientCodeOne() {
    return “ABCD_123″;
}

String getClientCodeTwo() {
    return “123_ABCD”;
}

MessageHandler handler = new MessageHandler();
handler.handleMessage(someMsg, getClientCodeOne);
```


没有创建新的类型和新的 class 层次，只是传入合适的函数作为参数，完成了面向对象方式同样的功能，同时还有一些额外的优点。没有使自己囿于类的层次之中：可以在运行时传入函数并在任何时候以更高的粒度更少的代码修改他们。编译器高效地为我们生成了面向对象的“粘合”代码！除此之外，我们还获得了所有函数式编程的其他好处。当然函数式语言提供的抽象不只这些，高阶函数只是一个开始。

## currying柯里化

```
def inc(x):
	def incx(y):
		return x+y
	return incx

inc2 = inc(2)
inc5 = inc(5)

print inc2(5)	// output 7
print inc5(5) // output 10
```

大牛 从参数分解的角度 对柯里化 的描述是：将一个函数的多个参数 分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这样可以简化函数的多个参数。






> 关于柯里化（currying），我们可以这么理解：柯里化就是一个函数在参数没给全时返回另一个函数，返回的函数的参数正好是余下的参数。比如：你制定了x和y, 如2的3次方,就返回8, 如果你只制定x为2,y没指定, 那么就返回一个函数：2的y次方, 这个函数只有一个参数:y。这样就非常容易理解吧。

目前不是很懂

参考

http://www.nowamagic.net/academy/detail/1220547


## 惰性求值

一旦我们接纳了函数式哲学，惰性（或延迟）求值这一技术会变得非常有趣。在讨论并行时已经见过下面的代码片断：

```java
String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
```

在一个命令式语言中求值顺序是确定的，因为每个函数都有可能会变更或依赖于外部状态，所以就必须有序的执行这些函数：首先是 somewhatLongOperation1，然后 somewhatLongOperation2，最后 concatenate，在函数式语言里就不尽然了。

前面提到只要确保没有函数修改或依赖于全局变量，somewhatLongOperation1 和 somewhatLongOperation2 可以被并行执行。

假设我们不想并行运行这两个函数，那是不是就按照字面顺序执行他们好了呢？答案是否定的，我们只在其他函数依赖于 s1 和 s2 时才需要执行这两个函数。我们甚至在 concatenate 调用之前都不必执行他们——可以把他们的求值延迟到 concatenate 函数内实际用到他们的位置。

如果用一个带有条件分支的函数替换 concatenate 并且只用了两个参数中的一个，另一个参数就永远没有必要被求值。在 Haskell 语言中，不确保一切都（完全）按顺序执行，因为 Haskell 只在必要时才会对其求值。

惰性求值优点众多，但缺点也不少。我们会在这里讨论它的优点而在下一节中解释其缺点。

**优化**

惰性求值有显著的优化潜力。惰性编译器看函数式代码就像数学家面对代数表达式——可以消去一部分而完全不去运行它，重新调整代码段以求更高的效率，甚至重整代码以降低出错，所有确定性优化（guaranteeing optimizations）不会破坏代码。这是严格用形式原语描述程序的巨大优势——代码固守着数学定律并可以数学的方式进行推理。

**抽象控制结构**

惰性求值提供了更高一级的抽象，它使得原本不可能的事情变成可能。例如，考虑实现如下的控制结构：

```
unless(stock.isEuropean()) {
    sendToSEC(stock);
}
```

我们希望只在祖先不是欧洲人时才执行 sendToSEC。如何实现 unless？如果没有惰性求值，我们需要某种形式的宏（macro）系统，但 Haskell 这样的语言不需要它。把他实现为一个函数即可：

```java
void unless(boolean condition, List code) {
    if(!condition)
        code;
}
```

注意如果条件为真，代码将不被执行。我们不能在一个严格（strict）的语言中再现这种求值，因为 unless 调用之前会先对参数进行求值。

**无穷（infinite）数据结构**

惰性求值允许定义无穷数据结构，对严格语言来说实现这个要复杂的多。

考虑一个 Fibonacci 数列，显然我们无法在有限的时间内计算出或在有限的内存里保存一个无穷列表。在严格语言如 Java 中，只能定义一个能返回 Fibonacci 数列中特定成员的 Fibonacci 函数，在 Haskell 中，我们对其进一步抽象并定义一个关于 Fibonacci 数的无穷列表，因为作为一个惰性的语言，只有列表中实际被用到的部分才会被求值。这使得可以抽象出很多问题并从一个更高的层次重新审视他们（例如，我们可以在一个无穷列表上使用表处理函数）。

**缺点**

当然从来不存在免费的午餐。惰性求值有很多的缺点，主要就在于…惰性。有很多现实世界的问题需要严格（按序）计算。例如考虑下例：

```
System.out.println(”Please enter your name: “);
System.in.readLine();
```

在惰性求值的语言里，不能保证第一行会在第二行之前执行！那么我们就不能进行输入输出操作，不能有意义地使用本地（native）接口（因为他们相互依赖其副作用必须被有序的调用），从而与整个世界隔离。如果引入允许特定执行顺序的原语又将失去数学地推理代码的诸多好处（为此将葬送函数式编程与其相关的所有优点）。

幸运的是，我们并非丧失了一切，数学家为此探索并开发出了许多技巧来保证在一定函数式设置下（functional setting）代码能以特定顺序执行。这样我们就赢得了两个世界。这些技术包括 continuation， monad 和 uniqueness typing（一致型别）。我只会在本文中解释 continuation，把 monad 和 uniqueness typing 留到将来的文章中。有趣的是，除了确保函数求值顺序， continuation 在很多别的情况下也很有用。这点等一会儿就会提到。



## Continuation/CPS

Continuations 对于程序设计的意义，就像达芬奇密码对人类历史的意义：即对人类最大秘密的惊人揭示。也许不是，但他在概念上的突破性至少和负数平方根的意义等同。

我们在学习函数时只了解了一半事实，因为我们基于一个错误的假定：函数只能将结果返回到它的调用端。从这个意义上说 continuation 是广义的函数，函数不必返回到其调用端而可以返回到程序的任何地方。我们把 “continuation” 作为参数传给一个函数，它指定了这个函数返回的位置。这个描述可能听起来挺复杂，看看下面的代码：

```c
int i = add(5, 10);
int j = square(i);
```

函数 add 在其被调用的位置将结果 15 赋给了 i，接下来 i 的值被用来调用 square。注意所有的惰性求值编译器都不能调整这几行代码因为第二行依赖着第一行的成功求值。下面用 continuation 风格又称 CPS（Continuation Programming Style）来重写这段代码，这里函数 add 会将结果返回到 square 而不是原来的调用函数。

	int j = add(5, 10, square);

这个例子中 add 有了另一个参数——一个 add 必须在它求值结束时用其返回值调用的函数。这里 square 是 add 的一个 continuation。这两种情况下，j 都将等于 255。

这就是强制使惰性语言有序地求值两个表达式的第一个技巧。考虑下面这个（熟悉的）IO 代码：

```java
System.out.println("Please enter your name: ");
System.in.readLine();
```

这里（我们假定改造过的） println 需要用自己的返回结果作为参数去调用 readLine 并将 readLine 返回值作为自己的返回值。这样就能确保这两行被有序执行而且 readLine 一定被执行（因为整个计算期望最后的结果为结果）。Java 的 println 返回 void 但如果它返回的是一个抽象值（readLine 所期待的），我们就解决了这个问题。这样串接的函数调用很快会让代码难以读懂，不过这可以避免，比如我们可以给语言添加些语法糖（syntactic sugar）将其变成按正常顺序输入的表达式，然后由编译器自动为我们串接这些函数调用。这样就可以如愿地强制求值顺序并保留一切函数式编程的好处（包括数学地对我们程序进行推理的能力）。如果还是不明白，试着把函数看作只有一个成员的类的实例，重写上述代码使得 println 和 readLine 成为类的实例，就比较容易清楚了。

如果我在此结束本节，那将仅仅涉及到 continuation 最浅显的应用，我们可以用 CPS 重写整个程序，所有的函数都增加一个额外的 continuation 参数并把函数结果传给它；也可以用另一种方法来重写：简单地把函数当作 continuation 的总是返回到调用端的特例。这种转换很容易自动化（事实上，许多编译器就是这么做的）。

一旦我们将一个程序转为了 CPS，那么很明显每个指令都将有些 continuation, 这是一个该指令在执行结束时会用其执行结果调用的函数（在通常的非 CPS 程序中，就是跳转到调用端的指令）。从上面随便选个例子，比如 add(5, 10)，在用 CPS 风格写的程序里，add 的 continuation 是一个 add 执行结束时会调用的函数，那么在非 CPS 的程序里它是什么呢？我们可以把程序转为 CPS，但有必要这么做吗？

其实没有必要。仔细看一下我们的 CPS 转换过程，如果尝试为它写一个编译器，那么经过长久思考后，你会意识到这个 CPS 的版本根本不需要栈！没有函数会以传统的意义“返回”，它只是用结果调用了另一个函数。我们无需在调用时将函数参数压栈再于调用结束时弹出栈，而只是简单的把他们保存在一大块内存中，然后使用跳转指令。不再需要原来的参数——他们不会再次被用到，因为没有函数会返回。

所以，用 CPS 风格写成的程序没有堆栈，但每个函数却有一个额外的参数可被调用；非 CPS 风格的程序没有可以被调用的这个参数，但却有栈；栈中存放着什么？只是参数和一个指向函数返回地址的指针。你看出端倪了吗？栈中只是放着 continuation 的信息！ 栈中指向返回指令的指针本质上和 CPS 程序里将被调用的函数是等价的。如果你想探究 add(5,10) 的 continuation，只要简单地检查它在堆栈的执行点！

所以，continuation 和栈上指向返回地址的指针是等价的，只是 continuation 被显式传递，所以不必和函数被调用点是同一位置。如果还记得 continuation 就是一个函数，并且在我们的语言里，函数被编译为一个类的实例，你就会理解指向栈中返回指令的指针实际就是 continuation。因为我们的函数（就像一个类的实例）只是一个指针，这意味着给定程序中任意时间和任意位置，你都可以去请求一个“当前 continuation”（current continuation，它就是当前的栈的信息）。

这样我们就知道了什么是“当前 continuation”。它有什么意义？一旦我们得到了当前的 continuation 并将它保存在某处，我们就最终将程序当前的状态保存了下来——及时地冷冻下来。这就像操作系统进入休眠状态。一个 continuation 对象里保存了从我们获得它的地方重新启动程序的必要信息。操作系统在每次发生线程间的上下文切换时也是如此。唯一的区别是它保留着全部控制。请求一个 continuation 对象（在 Scheme 里，可以调用 call-with-current-continuation 函数）后，你就会获得一个包括了当前 continuation 的对象，也就是堆栈信息（在 CPS 程序里就是下一个要调用的函数），可以把这个对象保存在一个变量（或者是磁盘）里。当你用这个 continuation “重启”程序时，就会转回到你取得这个对象的那个状态，这就象切换回一个被挂起的线程或唤醒休眠的操作系统，区别是用 continuation，你可以多次地重复这一过程，而当操作系统被唤醒时，休眠信息就被销毁了，如果那些信息没有被销毁，你也就可以一次次地将它唤醒到同一点，就象重返过去一样。有了 continuation 你就有了这个控制力！

Continuation 应该在什么情况下使用呢？通常在尝试模拟一个本质上是无状态的应用时可以简化你的任务。Continuation 很适合在 Web 应用程序中使用。微软公司的 ASP.NET 技术极尽苦心地模拟状态以便你在开发 Web 应用时少费周折，可如果 C# 支持了 continuation，ASP.NET 的复杂度就可以减半，你只需要保存一个 continuation，当用户下次发出 Web 请求时重启它即可。对程序员来说，web 应用程序将不再有中断，程序只是简单的从下一行重启！利用 continuation 这一抽象解决问题真是令人难以置信的便利，考虑到越来越多的胖客户端应用程序正在向服务器端转移，将来 continuation 也会变得越来越重要。


## 模式匹配

模式匹配不是什么新的创新特性，事实上，它和函数式编程的关系不大。把产生模式匹配归因于函数式编程的唯一的原因是函数式语言早就提供了模式匹配，然而现在的命令式语言还大多做不到。

让我们用一个例子深入了解一下模式匹配。这是一个 Java 的 Fibonacci 函数：

```
int fib(int n) {
    if(n == 0) return 1;
    if(n == 1) return 1;

    return fib(n – 2) + fib(n – 1);
}
```

让我们用 Java 衍生出的函数式语言来支持模式匹配：

```
int fib(0) {
    return 1;
}

int fib(1) {
    return 1;
}

int fib(int n) {
    return fib(n – 2) + fib(n – 1);
}
```

两者有什么区别？编译器为我们实现了分支。这有什么大不了？的确没什么，有人注意到很多函数包括了复杂的 switch 语句（尤其是在函数式程序中）所以认为这种抽象形式很好。

我们把一个函数定义分离成多个，然后把模式置于参数中（有点象重载）。当这个函数被调用时，编译器比较传入参数和函数定义然后选择其中正确的一个，这一般是通过选择可选的最特定的定义来完成。例如，int fib(int n) 可以在 n 等于 1 时被调用，但是实际上 fib(n) 没有被调用，因为 fib(1) 更加特定。

模式匹配通常要比我这个例子复杂，比如，高级模式匹配系统可以让我们这样做：

```
int f(int n < 10) { … }
int f(int n) { … }
```

模式匹配什么时候适用？情况太多了！每当你有一个嵌套着 if 的复杂的数据结构，这时就可以用模式匹配以更少的代码完成得更好。一个很好的例子闪现在我脑海，这就是所有 Win32 平台都提供了的标准的 WinProc 函数（即使它通常被抽象了）。通常模式匹配系统能检测集合也可以应付简单的值。例如，当传给函数一个数组后，就可以找出所有首元素为 1 第三个元素大于 3 的所有数组。

模式匹配还有一个好处：如果需要增加或修改条件，那么不必对付一个巨大的函数，只需增加或修改适合的定义即可，这消除了“四人帮”（GoF）书中的一大类设计模式。条件越复杂，模式匹配就越有用，一旦习惯了它，你就会担心没有了模式匹配的日子如何打发。


## Closures闭包

class test(object):
    a = 10

    def foo(self):
        b = 20





## 设计模式


函数作为“第一公民”后，设计模式的三大类创建、行为、结构中的行为型模式 都可以由函数嵌套、函数参数、函数返回值等直接实现（函数层面），无需上升java的类/接口层面了。换句话说，**设计模式由类/接口层面（java 提到设计模式都会有一个复杂的类图） 下沉到 函数层面了**，将一些功能或逻辑代码 通过函数的拼装（因此才有了柯里化 和 高阶函数等）来组织。





函数式编程越来越热门，因为不管是面向过程，还是面向对象，解决的都还是代码组织问题。软件生命周期中最大的过程是维护，维护基本就是debug，debug过程中又会产生新的bug。那么换个思路，干脆在编程阶段，如何编写易维护的代码？换句话说，哪些因素导致代码容易出bug？函数式编程在某些层面规避了这些。



# 问题

1. 什么是声明式编程？它与命令式编程有何区别？

	命令式编程通过一系列改变程序状态的指令来完成计算，声明式编程只描述程序应该完成的任务。命令式编程模拟电脑运算，是行动导向的，关键在于定义解法，即“怎么做”，因而算法是显性而目标是隐性的；声明式编程模拟人脑思维，是目标驱动的，关键在于描述问题，即“做什么”，因而目标是显性而算法是隐性的。


2. 什么是函数式和逻辑式？

	函数式编程通过数学函数的表达式变换和计算来求值。

	逻辑式编程通过一系列事实和规则，利用数理逻辑来推导或论证结论。

3. 变量在命令式编程和声明式编程中有何不同的涵义？

	命令式编程中的变量代表抽象化的内存，所存内容可能改变。声明式编程中的变量代表抽象化的符号，所指对象一般不会改变。



4. 声明式语言有何优点？为什么没有命令式语言流行？

	声明式编程专注问题的分析和表达而不是算法实现，不用指明执行顺序，一般没有或极少副作用，也不存在内存管理问题。这些都大大降低了编程的复杂度，同时也非常适合于并发式计算。

	编程语言的流行程度与其擅长的领域密切相关。函数式语言和逻辑式语言擅长基于数理逻辑的应用，命令式语言擅长基于业务逻辑的、尤其是交互式或事件驱动型的应用。

5. 命令式语言与声明式语言有无相通之处？

	声明式语言与命令式语言之间并无绝对的界限，它们均建立于低级语言之上，并且互相渗透融合。在命令式语言中引入函数或过程，是一种向声明式风格的趋近。

6. 编程的本质是什么？命令式、函数式和逻辑式分别采用了怎样的编程机制？

	编程是寻求一种机制，将指定的输入转化为指定的输出。

	三种核心编程范式采用如下不同的机制：
		- 命令式：自动机机制，通过设计指令完成从初始态到最终态的转变。
		- 函数式：数学变换机制，通过设计函数完成从自变量到因变量的计算。
		- 逻辑式：逻辑证明机制，通过逻辑推理完成从题设到结论的证明。


# 参考

http://www.nowamagic.net/academy/detail/1220547
