<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术博客 on L CJ的博客</title>
    <link>/post/</link>
    <description>Recent content in 技术博客 on L CJ的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>penguincj &amp;copy; 2019</copyright>
    <lastBuildDate>Tue, 28 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kubernetes网络框架</title>
      <link>/post/cloud/k8s/201905-k8s-network-arch/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201905-k8s-network-arch/</guid>
      <description>Kubernetes本身不提供容器网络，但具有可扩展的网络框架</description>
    </item>
    
    <item>
      <title>Why 容器云</title>
      <link>/post/cloud/container/201905-why-container-cloud/why-container/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/cloud/container/201905-why-container-cloud/why-container/</guid>
      <description>容器云解决大量项目构建运营环境的效率问题</description>
    </item>
    
    <item>
      <title>Kubernetes声明式API</title>
      <link>/post/cloud/k8s/201904-k8s-declarative-api/</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>/post/cloud/k8s/201904-k8s-declarative-api/</guid>
      <description>声明式API是Kubernetes成为容器编排事实标准的利器</description>
    </item>
    
    <item>
      <title>Kubernetes 框架</title>
      <link>/post/cloud/k8s/201811-k8s-arch/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201811-k8s-arch/</guid>
      <description>Kubernetes 云计算操作系统</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/cloud/k8s/201812-k8s-resource-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201812-k8s-resource-management/</guid>
      <description>参考 https://cizixs.com/2018/06/25/kubernetes-resource-management/</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/cloud/k8s/201901-how-read-kubeproxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201901-how-read-kubeproxy/</guid>
      <description>以阅读 K8S 一个模块 kube-proxy 来讲讲我是如何阅读源码的
架构 问题  Proxy 如何解决了同一主宿机相同服务端口冲突的问题？  参考 我是怎么阅读kubernetes源代码的？</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/cloud/k8s/201903-k8s-service-register.md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201903-k8s-service-register.md/</guid>
      <description>服务发现 Kubernetes 支持2种基本的服务发现模式 —— 环境变量和 DNS。
环境变量 当 Pod 运行在 Node 上，kubelet 会为每个活跃的 Service 添加一组环境变量。 它同时支持 Docker links 兼容 变量（查看 makeLinkVariables）、简单的 {SVCNAME}_SERVICE_HOST 和 {SVCNAME}_SERVICE_PORT 变量，这里 Service 的名称需大写，横线被转换成下划线。
举个例子，一个名称为 &amp;ldquo;redis-master&amp;rdquo; 的 Service 暴露了 TCP 端口 6379，同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service 生成了如下环境变量：
服务发布 对一些应用（如 Frontend）的某些部分，可能希望通过外部（Kubernetes 集群外部）IP 地址暴露 Service。
Kubernetes ServiceTypes 允许指定一个需要的类型的 Service，默认是 ClusterIP 类型。
Type 的取值以及行为如下：
 ClusterIP：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 ServiceType。 NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 :，可以从集群的外部访问一个 NodePort 服务。 LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。 ExternalName：通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容（例如， foo.</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/cloud/k8s/201904-k8s-loadbalancer.md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/cloud/k8s/201904-k8s-loadbalancer.md/</guid>
      <description>负载均衡的概念 负载均衡是将工作负载分布到多个服务器来提高网站、应用、数据库，来提高服务的性能和可靠性，是高可用网络基础架构的关键组件。
图1，负载均衡示意图
上图看到用户访问App时会先经过负载均衡（Load Balancer），再由负载均衡器将请求转发给后端服务器上的应用程序。
负载均衡主要分为两种：四层和七层负载均衡。
 四层负载均衡
基于IP+端口的负载均衡，即在OSI第4层工作，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。这种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。
 七层负载均衡
工作在OSI的最高层，第7层应用层，就是在四层的基础上，再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。
  图2，四层和七层负载均衡的区别
四层负载均衡更像是路由器的工作方式，修改IP后转发即可；七层负载均衡需要获取到应用层信息，就需要与客户端建立连接并且解析应用层的内容，同时与服务端建立连接，将请求发送到对应的后端服务上。
K8S 负载均衡 现在的后端服务从物理机向容器的运行环境转移，之前物理机的负载均衡已经不适用基于Kubernetes的容器网络了，Kubernetes也需要支持更加灵活和特性广泛的负载均衡。
云环境下后端服务是运行在容器里的，容器是用Kubernetes通过Pod来编排和管理的，Pod是一组功能密切相关的容器的合集，提供一种服务。
K8S 的负载均衡主要分为两个层面： - 集群内部层面，包括资源分配、内部流量的访问 - 外部访问集群
调度层面 分配Pod到Node时就会考虑将一个Service的Pod打散分布，根据资源的容量和性能来部署Pod。作为调度过程的一部分，它需要充分考虑管理可用性，避免遇到资源瓶颈。达到整体运行良好的运行状况。
Service 我们知道 Pod 的生命周期是短暂的，会因为一些原因而被销毁而在别的 Node 重新创建，因此 Pod 的 IP 地址会变化，而其他服务无法知道新的 IP 地址，这就需要定义一个 Service 暴露给其他服务使用，一个 Service 可以有一个或多个 Pod 逻辑分组的抽象，这样前端应用程序向 Service IP 发起请求就可以了，而不需要关心具体的 Pod 的状态和 IP。Service IP 是固定不变的。
Service通过标签来选取服务后端，一般配合Replication Controller或者Deployment来保证后端容器的正常运行。
Service有三种类型：
 ClusterIP：默认类型，自动分配一个仅cluster内部可以访问的虚拟IP NodePort：在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过:NodePort来访问该服务 LoadBalancer：在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到:NodePort  另外，也可以将已有的服务以Service的形式加入到Kubernetes集群中来，只需要在创建Service的时候不指定Label selector，而是在Service创建好后手动为其添加endpoint。
Service 通过 VIP 实现的是一个4层负载均衡的功能。</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/note/math/programmer-math-note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/note/math/programmer-math-note/</guid>
      <description>参考 《程序员的数学基础课》笔记</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/tech/how-to-read-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/tech/how-to-read-code/</guid>
      <description>参考 http://qiankunli.github.io/2019/01/24/source_parse.html</description>
    </item>
    
    <item>
      <title></title>
      <link>/post/tech/proto-note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/tech/proto-note/</guid>
      <description> 编码规则 Protobuf消息由字段（field）构成，每个字段有其规则（rule）、数据类型（type）、字段名（name）、tag，以及选项（option）。比如下面这段代码描述了由多个字段构成的 Person 消息：
message Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; }  </description>
    </item>
    
  </channel>
</rss>